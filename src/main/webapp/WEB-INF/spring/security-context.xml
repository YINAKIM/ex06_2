<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:security="http://www.springframework.org/schema/security"
       xsi:schemaLocation="http://www.springframework.org/schema/security
       http://www.springframework.org/schema/security/spring-security.xsd
        http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--직접 만든 접근제한 핸들러 : security:http안에 ref로 참조-->
    <bean id="customAccessDenied" class="org.zerock.security.CustomAccessDeniedHandler"/>

    <!-- 권한 별 로그인 후처리 해주는 CustomLoginSuccessHandler 를 빈으로 등록 -->
    <bean id="customLoginSuccess" class="org.zerock.security.CustomLoginSuccessHandler"/>

    <!--
    * POST방식으로 처리하는 로그아웃은 원래 스프링시큐리티 내부에서 동작하는데,
    * 만약 로그아웃 후에 추가적인 작업이 필요하다면
    * implements LogoutSuccessHandler 로 구현체 만들어서 작업하면됨
    * 이건그냥 내가 해볼라고 만든거,
    ==> 근데 테스트 해봤는데 success-handler-ref="customLogoutSuccess" 이거 쓰려면 기본 로그아웃을 꺼야됨
    기본로그아웃이 우선임
    -->
  <bean id="customLogoutSuccess" class="org.zerock.security.CustomLogoutSuccessHandler"/>

    <security:http auto-config="true" use-expressions="true">
        <!-- security:intercept-url => 특정 URI접근시 인터셉터를 이용하여 접근제한
             pattern속성 : URI패턴 지정
             access속성 : 권한체크
             access속성 값 지정하는 2가지 방법
             1. 표현식이용 : <security:http>의 기본설정방법 ,
             2. 문자열 이용  : 만약 [2. 문자열]방법으로 하고싶으면 use-expression="false"지정할 것, 그리고 이방법으로 하면 JSP에서 처리할 때 방법이 다름
             -->


        <!-- role별로 인터셉팅할 url -->
        <security:intercept-url pattern="/sample/all" access="permitAll"/>
        <security:intercept-url pattern="/sample/member" access="hasRole('ROLE_MEMBER')"/>
        <security:intercept-url pattern="/sample/admin" access="hasRole('ROLE_ADMIN')"/>

        <!-- 로그인페이지 -->
        <!-- 로그인 성공 후처리 핸들러 : 권한 별로 지정한 페이지로 redirect해줌 -->
        <security:form-login login-page="/customLogin" authentication-success-handler-ref="customLoginSuccess"/>

        <!-- 접근제한 핸들러 -->
        <security:access-denied-handler ref="customAccessDenied"/>
    <!--<security:access-denied-handler error-page="/accessError"/> : error-page, ref 둘중하나만 사용-->

        <!-- CSRF 토큰 활성화 : false가  기본값
                           : 방어O (false하면 토큰값받아서 확인절차로 방어한다는 뜻)

                           / true하면 방어 X 다들어와 -->
<!--    <security:csrf disabled="true"/>-->


        <!--  로그아웃 핸들러 등록 -->
  <security:logout logout-url="/springLogout" invalidate-session="true"/>

        <!--내가만든 로그아웃 핸들러 ref추가한 로그아웃핸들러-->
<!--       <security:logout logout-url="/customLogout" invalidate-session="true" success-handler-ref="customLogoutSuccess"/>-->
    </security:http>



    <security:authentication-manager>
        <security:authentication-provider>
            <security:jdbc-user-service data-source-ref="dataSource"/>
<!--dataSource로 user정보를 가져온다.(p.647)
[1] 내가 멍청하게 users 테이블에 insert할 때 대문자로 써서 ㅋㅋㅋㅋ계정정보가 대문자로 들어가짐
[2] 아직 PasswordEncoder없어서 (비밀번호가 평문이라서) 500에러 나오는게 정상
java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"
-->

<!--이건 DB없이 그냥 InMemoryUserDatailsmanager이용해서 테스트 했던것, jdbc_Login_note.txt참고할 것

            <security:user-service>
                <security:user name="member"  password="{noop}member" authorities="ROLE_MEMBER"/>
                <security:user name="admin"  password="{noop}admin" authorities="ROLE_MEMBER, ROLE_ADMIN"/>
            </security:user-service>
-->
        </security:authentication-provider>
    </security:authentication-manager>



</beans>